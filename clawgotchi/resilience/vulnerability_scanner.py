"""
Vulnerability Scanner for MCP CVE Detection

Scans code for known vulnerable patterns including:
- CVE-2024-51181: XSS in WebGL contexts
- CVE-2024-50854/50851/50853/50852: Tenda RCE/buffer overflow patterns
- CVE-2024-10124: Auth bypass patterns
- CVE-2024-9708: SVG file upload patterns
- CVE-2024-11015: SQL injection patterns
"""

import re
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional


class Severity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = 9.0
    HIGH = 7.0
    MEDIUM = 5.0
    LOW = 3.0
    INFO = 1.0


class VulnerabilityType(Enum):
    """Types of vulnerabilities."""
    XSS = "Cross-Site Scripting"
    RCE = "Remote Code Execution"
    BUFFER_OVERFLOW = "Buffer Overflow"
    AUTH_BYPASS = "Authentication Bypass"
    SQL_INJECTION = "SQL Injection"
    FILE_UPLOAD = "Insecure File Upload"
    UNKNOWN = "Unknown"


@dataclass
class VulnerabilityReport:
    """Report of a detected vulnerability."""
    vulnerability_type: VulnerabilityType
    severity: Severity
    cve_id: str
    location: str
    line_number: int
    description: str = ""
    remediation: str = ""

    def to_dict(self) -> dict:
        return {
            "type": self.vulnerability_type.value,
            "severity": self.severity.value,
            "cve_id": self.cve_id,
            "location": self.location,
            "line_number": self.line_number,
            "description": self.description,
            "remediation": self.remediation
        }


@dataclass
class ScanResult:
    """Result of a vulnerability scan."""
    file_scanned: str
    vulnerabilities: List[VulnerabilityReport] = field(default_factory=list)
    lines_scanned: int = 0
    scan_time_ms: float = 0.0

    def has_vulnerabilities(self) -> bool:
        return len(self.vulnerabilities) > 0

    def get_critical_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == Severity.CRITICAL)

    def get_high_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == Severity.HIGH)


class VulnerabilityScanner:
    """
    Scans code for known vulnerable patterns.
    
    Designed to detect MCP-related CVEs and common web vulnerabilities.
    """

    # CVE Patterns: (Regex Pattern, CVE ID, Type, Severity, Description, Remediation)
    PATTERNS = [
        # CVE-2024-51181: XSS in WebGL contexts
        (
            r"getContext\s*\(\s*['\"]webgl['\"]",
            "CVE-2024-51181",
            VulnerabilityType.XSS,
            Severity.MEDIUM,
            "WebGL context access detected - potential XSS vector if input is not sanitized",
            "Ensure WebGL input is properly sanitized and use Content Security Policy"
        ),
        # CVE-2024-50854/50851/50853/50852: Tenda RCE/Buffer Overflow
        (
            r"system\s*\([^)]*\$",
            "CVE-2024-50854",
            VulnerabilityType.RCE,
            Severity.CRITICAL,
            "System call with user-controlled input detected - potential RCE",
            "Avoid passing user input to system() calls. Use safe APIs."
        ),
        (
            r"strcpy\s*\(",
            "CVE-2024-50851",
            VulnerabilityType.BUFFER_OVERFLOW,
            Severity.CRITICAL,
            "strcpy detected - classic buffer overflow vulnerability",
            "Use strncpy or safe string handling functions"
        ),
        # CVE-2024-10124: Auth Bypass
        (
            r"if\s*\(\s*\$[\w]+\s*==\s*['\"]admin['\"]",
            "CVE-2024-10124",
            VulnerabilityType.AUTH_BYPASS,
            Severity.HIGH,
            "Simple string comparison for admin authentication - easily bypassed",
            "Use proper authentication mechanisms with secure password handling"
        ),
        # CVE-2024-9708: SVG File Upload
        (
            r"move_uploaded_file\s*\(",
            "CVE-2024-9708",
            VulnerabilityType.FILE_UPLOAD,
            Severity.HIGH,
            "File upload detected - ensure proper validation to prevent malicious uploads",
            "Validate file type, scan for malware, and store outside web root"
        ),
        # CVE-2024-11015: SQL Injection
        (
            r"SELECT\s+\*?\s*FROM\s+.*?\$",
            "CVE-2024-11015",
            VulnerabilityType.SQL_INJECTION,
            Severity.CRITICAL,
            "Direct user input in SQL query detected - SQL injection risk",
            "Use parameterized queries or prepared statements"
        ),
        # Generic SQL Injection Patterns (more specific to avoid double match)
        (
            r"\.\s*\$_(GET|POST|REQUEST|COOKIE)",
            "CVE-2024-11015",
            VulnerabilityType.SQL_INJECTION,
            Severity.HIGH,
            "Concatenating user input into queries - SQL injection risk",
            "Use parameterized queries"
        ),
        # Generic XSS Patterns
        (
            r"innerHTML\s*=\s*(\$\w+|[\w']+)",
            "CVE-2024-51181",
            VulnerabilityType.XSS,
            Severity.HIGH,
            "Setting innerHTML with user input - XSS vulnerability",
            "Use textContent or DOMPurify instead"
        ),
        # Eval Injection
        (
            r"eval\s*\(",
            "CVE-2024-50854",
            VulnerabilityType.RCE,
            Severity.CRITICAL,
            "eval() usage detected - potential code injection vulnerability",
            "Avoid eval() with user input"
        ),
        # Include Injection
        (
            r"include\s*\(\s*\$",
            "CVE-2024-50854",
            VulnerabilityType.RCE,
            Severity.HIGH,
            "include() with user input - local file inclusion vulnerability",
            "Validate file paths and use whitelists"
        ),
    ]

    def __init__(self):
        self.patterns = []
        for pattern_info in self.PATTERNS:
            # Support both tuple and extended tuple formats
            if len(pattern_info) == 5:
                pattern, cve_id, vtype, severity, description = pattern_info
                remediation = "See CVE documentation"
            else:
                pattern, cve_id, vtype, severity, description, remediation = pattern_info
            
            try:
                compiled = re.compile(pattern)
                self.patterns.append({
                    "regex": compiled,
                    "cve_id": cve_id,
                    "type": vtype,
                    "severity": severity,
                    "description": description,
                    "remediation": remediation
                })
            except re.error as e:
                # Log invalid regex but continue
                print(f"[WARNING] Invalid regex pattern: {pattern} - {e}")

    def scan_code(self, code: str, filename: str = "unknown") -> ScanResult:
        """
        Scan a code string for vulnerabilities.
        
        Args:
            code: The code string to scan
            filename: Optional filename for reporting
            
        Returns:
            ScanResult containing vulnerabilities found
        """
        import time
        start_time = time.time()
        
        result = ScanResult(file_scanned=filename)
        lines = code.split('\n')
        result.lines_scanned = len(lines)
        
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith('//') or line.startswith('#'):
                continue
                
            for pattern_info in self.patterns:
                match = pattern_info["regex"].search(line)
                if match:
                    vuln = VulnerabilityReport(
                        vulnerability_type=pattern_info["type"],
                        severity=pattern_info["severity"],
                        cve_id=pattern_info["cve_id"],
                        location=f"{filename}:{line_num}",
                        line_number=line_num,
                        description=pattern_info["description"],
                        remediation=pattern_info["remediation"]
                    )
                    result.vulnerabilities.append(vuln)
        
        result.scan_time_ms = (time.time() - start_time) * 1000
        return result

    def scan_file(self, filepath: str) -> ScanResult:
        """
        Scan a file for vulnerabilities.
        
        Args:
            filepath: Path to the file to scan
            
        Returns:
            ScanResult containing vulnerabilities found
        """
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                code = f.read()
            return self.scan_code(code, filepath)
        except FileNotFoundError:
            return ScanResult(file_scanned=filepath, vulnerabilities=[])
        except Exception as e:
            return ScanResult(file_scanned=filepath, vulnerabilities=[])

    def scan_directory(self, directory: str, extensions: List[str] = None) -> List[ScanResult]:
        """
        Scan all files in a directory for vulnerabilities.
        
        Args:
            directory: Path to the directory to scan
            extensions: List of file extensions to scan (e.g., ['.py', '.php'])
            
        Returns:
            List of ScanResult for each file scanned
        """
        import os
        from pathlib import Path
        
        results = []
        if extensions is None:
            extensions = ['.py', '.php', '.js', '.html', '.ts']
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                if any(file.endswith(ext) for ext in extensions):
                    filepath = os.path.join(root, file)
                    results.append(self.scan_file(filepath))
        
        return results

    def get_summary(self, results: List[ScanResult]) -> dict:
        """
        Get a summary of scan results.
        
        Args:
            results: List of ScanResult objects
            
        Returns:
            Dictionary with summary statistics
        """
        total_vulns = 0
        by_severity = {s: 0 for s in Severity}
        by_type = {}
        by_cve = {}
        
        for result in results:
            for vuln in result.vulnerabilities:
                total_vulns += 1
                by_severity[vuln.severity] += 1
                
                if vuln.vulnerability_type.value not in by_type:
                    by_type[vuln.vulnerability_type.value] = 0
                by_type[vuln.vulnerability_type.value] += 1
                
                if vuln.cve_id not in by_cve:
                    by_cve[vuln.cve_id] = 0
                by_cve[vuln.cve_id] += 1
        
        return {
            "files_scanned": len(results),
            "total_vulnerabilities": total_vulns,
            "by_severity": {s.value: by_severity[s] for s in Severity},
            "by_type": by_type,
            "by_cve": by_cve
        }
